<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Telegram WebApp — QR Scanner</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8;color-scheme:dark}
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial}
    body{background:linear-gradient(180deg,#071029 0%, #071a2a 100%);display:flex;align-items:center;justify-content:center;padding:16px}
    .app{width:100%;max-width:780px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
    header{display:flex;gap:12px;align-items:center;margin-bottom:8px}
    h1{font-size:16px;margin:0;color:#e6eef6}
    p.lead{margin:0;color:var(--muted);font-size:13px}
    .viewer{position:relative;border-radius:10px;overflow:hidden;background:#000;height:420px;display:flex;align-items:center;justify-content:center}
    video{width:100%;height:100%;object-fit:cover}
    canvas{display:none}
    .overlay{position:absolute;inset:0;pointer-events:none}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    button,select{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px;color:#e6eef6}
    .result{
      margin-top:12px;
      padding:10px;
      border-radius:8px;
      /* Базовый фон */
      background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
      color:#dbeafe;
      transition: background 0.3s ease; /* Добавляем плавный переход для индикатора */
    }
    .muted{color:var(--muted);font-size:13px}
    .big{font-weight:600}
    .center{display:flex;align-items:center;justify-content:center}
    .hidden{display:none}
    footer{margin-top:10px;text-align:center;color:var(--muted);font-size:12px}
  </style>
</head>
<body>
  <div class="app" role="application">
    <header>
      <div>
        <h1>QR Scanner 2 — Telegram Web App</h1>
        <p class="lead">Откройте в Telegram (Web App) и используйте камеру для сканирования QR.</p>
      </div>
    </header>

    <div class="viewer" id="viewer">
      <video id="video" playsinline></video>
      <canvas id="canvas" aria-hidden="true"></canvas>
      <svg class="overlay" id="overlay" viewBox="0 0 100 100" preserveAspectRatio="none">
        <rect x="5" y="5" width="90" height="90" stroke="rgba(255,255,255,0.06)" fill="none" rx="6"/>
      </svg>
    </div>

    <div class="controls">
      <select id="cameras" aria-label="Выбор камеры"></select>
      <button id="startBtn">Запустить</button>
      <button id="stopBtn" class="hidden">Остановить</button>
      <button id="torchBtn" class="hidden">Фонарик</button>
      <button id="copyBtn" class="hidden">Копировать</button>
    </div>

    <div class="result" id="result" aria-live="polite">
      <div class="muted">Результат:</div>
      <div id="output" class="big">—</div>
    </div>

    <footer>
      <div class="muted">При обнаружении QR данные будут автоматически отправлены боту.</div>
    </footer>
  </div>

  <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>
  <script>
    // Простая Telegram WebApp + QR scanner (один файл). Работает в мобильных/десктоп браузерах.
    (function(){
      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const cameras = document.getElementById('cameras');
      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const torchBtn = document.getElementById('torchBtn');
      const copyBtn = document.getElementById('copyBtn');
      const output = document.getElementById('output');
      const resultDiv = document.getElementById('result'); // Добавлено для индикатора

      let stream = null;
      let scanning = false;
      let scanInterval = null;
      let currentTrack = null;
      let supportsTorch = false;
      let torchOn = false;
      const tg =window.Telegram && window.Telegram.WebApp; // Получаем объект WebApp

      // Initialize Telegram WebApp if available
      function initTelegram(){
        if(tg){
          try{ tg.ready(); }catch(e){}
          // Скрываем основную кнопку, так как отправка будет автоматической.
          tg.MainButton.hide();
        }
      }

      async function listCameras(){
        try{
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoInputs = devices.filter(d=>d.kind === 'videoinput');
          cameras.innerHTML = '';
          videoInputs.forEach((d,i)=>{
            const opt = document.createElement('option');
            opt.value = d.deviceId;
            opt.textContent = d.label || `camera ${i+1}`;
            cameras.appendChild(opt);
          });
          if(videoInputs.length <= 1) cameras.style.display = 'none';
          else cameras.style.display = 'inline-block';
        }catch(e){ console.error('listCameras', e); }
      }

      async function startCamera(deviceId){
        stopCamera();
        const constraints = {
          audio:false,
          video: {
            deviceId: deviceId ? { exact: deviceId } : undefined,
            facingMode: 'environment',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        };
        try{
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
          await video.play();
          currentTrack = stream.getVideoTracks()[0];

          // torch support
          const imageCapture = ('ImageCapture' in window && new ImageCapture(currentTrack));
          if(imageCapture && typeof currentTrack.getCapabilities === 'function'){
            try{
              const caps = currentTrack.getCapabilities();
              supportsTorch = !!caps.torch;
              torchBtn.classList.toggle('hidden', !supportsTorch);
            }catch(e){ supportsTorch=false; torchBtn.classList.add('hidden'); }
          }

          scanning = true;
          stopBtn.classList.remove('hidden');
          startBtn.classList.add('hidden');
          copyBtn.classList.add('hidden');
          handleResult(''); // Сброс результата

          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;

          scanLoop();
        }catch(err){
          console.error('startCamera error', err);
          alert('Ошибка доступа к камере: ' + (err.message || err.name));
        }
      }

      function stopCamera(){
        scanning = false;
        if(scanInterval) { clearTimeout(scanInterval); scanInterval = null; }
        if(stream){
          stream.getTracks().forEach(t=>t.stop());
          stream = null;
        }
        currentTrack = null;
        video.pause();
        video.srcObject = null;
        startBtn.classList.remove('hidden');
        stopBtn.classList.add('hidden');
        torchBtn.classList.add('hidden');
      }

      async function toggleTorch(){
        if(!currentTrack) return;
        try{
          torchOn = !torchOn;
          await currentTrack.applyConstraints({ advanced: [{ torch: torchOn }] });
          torchBtn.textContent = torchOn ? 'Фонарик: вкл' : 'Фонарик: выкл';
        }catch(e){ console.warn('Torch error', e); }
      }

      function handleResult(text, autoSend = false){
        output.textContent = text || '—';
        copyBtn.classList.toggle('hidden', !text);
        try{
            tg.sendData(text);
            
            // 2. Индикатор отправки (зеленый фон)
            resultDiv.style.background = 'linear-gradient(180deg, rgba(34,197,94,0.1), rgba(34,197,94,0.05))';
            output.textContent = '✅ Отправлено! ' + text;

            // 3. Остановка сканера и сброс индикатора через небольшой таймаут
            setTimeout(()=>{
              stopCamera();
              // Возвращаем базовый фон
              resultDiv.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01))';
            }, 1000); 

        }catch(e){ 
            console.warn('sendData failed', e); 
            // В случае ошибки сбросить фон на красный (опционально)
            resultDiv.style.background = 'linear-gradient(180deg, rgba(239,68,68,0.1), rgba(239,68,68,0.05))';
            output.textContent = '❌ Ошибка отправки: ' + text;
            setTimeout(()=>{
                resultDiv.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01))';
            }, 3000);
          }
        }
      }

      function scanLoop(){
        if(!scanning) return;
        if(video.readyState === video.HAVE_ENOUGH_DATA){
          try{
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
            let code = null;

            // Use BarcodeDetector if available
            if(window.BarcodeDetector && BarcodeDetector.getSupportedFormats){
              BarcodeDetector.getSupportedFormats().then(formats=>{
                if(formats.includes('qr_code')){
                  const detector = new BarcodeDetector({formats:['qr_code']});
                  detector.detect(imageData).then(barcodes=>{
                    if(barcodes && barcodes.length){
                      code = barcodes[0].rawValue;
                    }
                  }).catch(()=>{});
                }
                
                if(!code){
                   // fallback to jsQR if BarcodeDetector didn't find anything or format not supported
                   const jsqr_code = jsQR(imageData.data, imageData.width, imageData.height);
                   if(jsqr_code){ code = jsqr_code.data; }
                }

                if(code && scanning) {
                    handleResult(code, true);
                    return; // Успешное сканирование, выходим из цикла
                }

              }).catch(()=>{
                // fallback to jsQR if BarcodeDetector promise failed
                const jsqr_code = jsQR(imageData.data, imageData.width, imageData.height);
                if(jsqr_code){ code = jsqr_code.data; }

                if(code && scanning) {
                    handleResult(code, true);
                    return;
                }
              });
            }else{
              // fallback to jsQR
              const jsqr_code = jsQR(imageData.data, imageData.width, imageData.height);
              if(jsqr_code){ code = jsqr_code.data; }

              if(code && scanning) {
                  handleResult(code, true);
                  return;
              }
            }

          }catch(e){ console.error('scanLoop error', e); }
        }
        // schedule next frame only if still scanning
        if(scanning) {
            scanInterval = setTimeout(scanLoop, 250);
        }
      }

      // copy
      copyBtn.addEventListener('click', ()=>{
        const text = output.textContent || '';
        if(!text) return;
        navigator.clipboard.writeText(text).then(()=>{
          copyBtn.textContent = 'Скопировано';
          setTimeout(()=> copyBtn.textContent = 'Копировать', 1200);
        }).catch(()=> alert('Не удалось скопировать'));
      });

      startBtn.addEventListener('click', async ()=>{
        const devId = cameras.value || undefined;
        await startCamera(devId);
      });
      stopBtn.addEventListener('click', ()=> stopCamera());
      torchBtn.addEventListener('click', ()=> toggleTorch());

      cameras.addEventListener('change', async ()=>{
        if(scanning){
          await startCamera(cameras.value);
        }
      });

      // initial run
      (async function(){
        initTelegram();
        await listCameras();
      })();

      // Cleanup on page hide/unload
      window.addEventListener('pagehide', stopCamera);
      window.addEventListener('beforeunload', stopCamera);

    })();
  </script>

</body>
  </html>
